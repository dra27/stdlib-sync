 (** [compare s0 s1] sorts [s0] and [s1] in lexicographical order. [compare]
     behaves like {!Stdlib.compare} on strings but may be more efficient. *)
 
-val starts_with : prefix:string -> string -> bool
-(** [starts_with ~prefix s] is [true] if and only if [s] starts with [prefix].
+val starts_with : string -> string -> bool
+(** [starts_with prefix s] is [true] if and only if [s] starts with [prefix].
 
     @since 4.12.0 *)
 
-val ends_with : suffix:string -> string -> bool
-(** [ends_with ~suffix s] is [true] if and only if [s] ends with [suffix].
+val ends_with : string -> string -> bool
+(** [ends_with suffix s] is [true] if and only if [s] ends with [suffix].
 
     @since 4.12.0 *)
 
    Text mode is supported only if the descriptor refers to a file
    or pipe, but is not supported if it refers to a socket.
 
-   On Windows: {!Stdlib.set_binary_mode_in} always fails on channels
-   created with this function.
+   On Windows: [set_binary_mode_in] always fails on channels created
+   with this function.
 
-   Beware that input channels are buffered, so more characters may
-   have been read from the descriptor than those accessed using
-   channel functions.  Channels also keep a copy of the current
-   position in the file.
-
-   Closing the channel [ic] returned by [in_channel_of_descr fd]
-   using [close_in ic] also closes the underlying descriptor [fd].
-   It is incorrect to close both the channel [ic] and the descriptor [fd].
-
-   If several channels are created on the same descriptor, one of the
-   channels must be closed, but not the others.
-   Consider for example a descriptor [s] connected to a socket and two
-   channels [ic = in_channel_of_descr s] and [oc = out_channel_of_descr s].
-   The recommended closing protocol is to perform [close_out oc],
-   which flushes buffered output to the socket then closes the socket.
-   The [ic] channel must not be closed and will be collected by the GC
-   eventually.
-*)
+   Beware that channels are buffered so more characters may have been
+   read from the file descriptor than those accessed using channel functions.
+   Channels also keep a copy of the current position in the file.
+
+   You need to explicitly close all channels created with this function.
+   Closing the channel also closes the underlying file descriptor (unless
+   it was already closed). *)
 
 val out_channel_of_descr : file_descr -> out_channel
 (** Create an output channel writing on the given descriptor.
    Text mode is supported only if the descriptor refers to a file
    or pipe, but is not supported if it refers to a socket.
 
-   On Windows: {!Stdlib.set_binary_mode_out} always fails on channels created
+   On Windows: [set_binary_mode_out] always fails on channels created
    with this function.
 
-   Beware that output channels are buffered, so you may have to call
-   {!Stdlib.flush} to ensure that all data has been sent to the
-   descriptor.  Channels also keep a copy of the current position in
-   the file.
-
-   Closing the channel [oc] returned by [out_channel_of_descr fd]
-   using [close_out oc] also closes the underlying descriptor [fd].
-   It is incorrect to close both the channel [ic] and the descriptor [fd].
-
-   See {!Unix.in_channel_of_descr} for a discussion of the closing
-   protocol when several channels are created on the same descriptor.
-*)
+   Beware that channels are buffered so you may have to [flush] them
+   to ensure that all data has been sent to the file descriptor.
+   Channels also keep a copy of the current position in the file.
+
+   You need to explicitly close all channels created with this function.
+   Closing the channel flushes the data and closes the underlying file
+   descriptor (unless it has already been closed, in which case the
+   buffered data is lost).*)
 
 val descr_of_in_channel : in_channel -> file_descr
 (** Return the descriptor corresponding to an input channel. *)
    [link(2)] function is used whose behaviour is OS-dependent, but more widely
    available.
 
-   @raise ENOSYS On {e Unix} if [~follow:_] is requested, but linkat is
+   @raise ENOSYS On {e Unix} if [follow:_] is requested, but linkat is
                  unavailable.
-   @raise ENOSYS On {e Windows} if [~follow:false] is requested. *)
+   @raise ENOSYS On {e Windows} if [follow:false] is requested. *)
 
 
 (** {1 File permissions and ownership} *)
    the Unix module that create file descriptors have an optional
    argument [?cloexec:bool] to indicate whether the file descriptor
    should be created in ``close-on-exec'' mode (by writing
-   [~cloexec:true]) or in ``keep-on-exec'' mode (by writing
-   [~cloexec:false]).  For historical reasons, the default file
+   [cloexec:true]) or in ``keep-on-exec'' mode (by writing
+   [cloexec:false]).  For historical reasons, the default file
    descriptor creation mode is ``keep-on-exec'', if no [cloexec] optional
    argument is given.  This is not a safe default, hence it is highly
    recommended to pass explicit [cloexec] arguments to operations that
    completes.  If another thread spawns another program during this window,
    the descriptor will leak, as it is still in the ``keep-on-exec'' mode.
 
-   Regarding the atomicity guarantees given by [~cloexec:true] or by
+   Regarding the atomicity guarantees given by [cloexec:true] or by
    the use of the [O_CLOEXEC] flag: on all platforms it is guaranteed
    that a concurrently-executing Caml thread cannot leak the descriptor
    by starting a new process.  On Linux, this guarantee extends to
 (** Connect to a server at the given address.
    Return a pair of buffered channels connected to the server.
    Remember to call {!Stdlib.flush} on the output channel at the right
-   times to ensure correct synchronization.
-
-   The two channels returned by [open_connection] share a descriptor
-   to a socket.  Therefore, when the connection is over, you should
-   call {!Stdlib.close_out} on the output channel, which will also close
-   the underlying socket.  Do not call {!Stdlib.close_in} on the input
-   channel; it will be collected by the GC eventually.
-*)
-
+   times to ensure correct synchronization. *)
 
 val shutdown_connection : in_channel -> unit
 (** ``Shut down'' a connection established with {!open_connection};
    that is, transmit an end-of-file condition to the server reading
-   on the other side of the connection. This does not close the
-   socket and the channels used by the connection.
-   See {!Unix.open_connection} for how to close them once the
-   connection is over. *)
+   on the other side of the connection. This does not fully close the
+   file descriptor associated with the channel, which you must remember
+   to free via {!Stdlib.close_in}. *)
 
 val establish_server :
   (in_channel -> out_channel -> unit) -> sockaddr -> unit
    is created for each connection. The function {!establish_server}
    never returns normally.
 
-   The two channels given to the function share a descriptor to a
-   socket.  The function does not need to close the channels, since this
-   occurs automatically when the function returns.  If the function
-   prefers explicit closing, it should close the output channel using
-   {!Stdlib.close_out} and leave the input channel unclosed,
-   for reasons explained in {!Unix.in_channel_of_descr}.
-
    On Windows: not implemented (use threads). *)
 
 
   (** {1 Generic interface} *)
 
 
-  type (!'a, !'b) t
+  type (!'a, !'b) t = ('a, 'b) Hashtbl.t
   (** The type of hash tables from type ['a] to type ['b]. *)
 
   val create : ?random:bool -> int -> ('a, 'b) t
      the table.  The table grows as needed, so [n] is just an
      initial guess.
 
-     The optional [~random] parameter (a boolean) controls whether
+     The optional [random] parameter (a boolean) controls whether
      the internal organization of the hash table is randomized at each
      execution of [Hashtbl.create] or deterministic over all executions.
 
-     A hash table that is created with [~random] set to [false] uses a
+     A hash table that is created with [random] set to [false] uses a
      fixed hash function ({!hash}) to distribute keys among
      buckets.  As a consequence, collisions between keys happen
      deterministically.  In Web-facing applications or other
      denial-of-service attack: the attacker sends input crafted to
      create many collisions in the table, slowing the application down.
 
-     A hash table that is created with [~random] set to [true] uses the seeded
+     A hash table that is created with [random] set to [true] uses the seeded
      hash function {!seeded_hash} with a seed that is randomly chosen at hash
      table creation time.  In effect, the hash function used is randomly
      selected among [2^{30}] different hash functions.  All these hash
      or {!iter} is no longer deterministic: elements are enumerated in
      different orders at different runs of the program.
 
-     If no [~random] parameter is given, hash tables are created
+     If no [random] parameter is given, hash tables are created
      in non-random mode by default.  This default can be changed
      either programmatically by calling {!randomize} or by
      setting the [R] flag in the [OCAMLRUNPARAM] environment variable.
 
-     @before 4.00.0 the [~random] parameter was not present and all
+     @before 4.00.0 the [random] parameter was not present and all
      hash tables were created in non-randomized mode. *)
 
   val clear : ('a, 'b) t -> unit
   val randomize : unit -> unit
   (** After a call to [Hashtbl.randomize()], hash tables are created in
       randomized mode by default: {!create} returns randomized
-      hash tables, unless the [~random:false] optional parameter is given.
+      hash tables, unless the [random:false] optional parameter is given.
       The same effect can be achieved by setting the [R] parameter in
       the [OCAMLRUNPARAM] environment variable.
 
       Note that once [Hashtbl.randomize()] was called, there is no way
       to revert to the non-randomized default behavior of {!create}.
       This is intentional.  Non-randomized hash tables can still be
-      created using [Hashtbl.create ~random:false].
+      created using [Hashtbl.create random:false].
 
       @since 4.00.0 *)
 
       @since 4.12.0 *)
 
   (** @since 4.00.0 *)
-  type statistics = {
+  type statistics = Hashtbl.statistics = {
     num_bindings: int;
       (** Number of bindings present in the table.
           Same value as returned by {!length}. *)
     end
   (** The output signature of the functor {!Make}. *)
 
-  module Make (H : HashedType) : S with type key = H.t
+    module Make : functor (H : HashedType) -> S
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.Make(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.Make] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
   (** The output signature of the functor {!MakeSeeded}.
       @since 4.00.0 *)
 
-  module MakeSeeded (H : SeededHashedType) : SeededS with type key = H.t
+    module MakeSeeded (H : SeededHashedType) : SeededS
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.MakeSeeded(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.MakeSeeded] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
       interface, but use the seeded hashing and equality functions
       specified in the functor argument [H] instead of generic
       equality and hashing.  The [create] operation of the
-      result structure supports the [~random] optional parameter
-      and returns randomized hash tables if [~random:true] is passed
+      result structure supports the [random] optional parameter
+      and returns randomized hash tables if [random:true] is passed
       or if randomization is globally on (see {!Hashtbl.randomize}).
       @since 4.00.0 *)
 
      an integer seed.  Usage:
      [Hashtbl.seeded_hash_param meaningful total seed x].
      @since 4.00.0 *)
+
   (** Association tables over ordered types.
 
      This module implements applicative association tables, also known as
          @before 4.03 Physical equality was not ensured. *)
 
       val merge:
-           (key -> 'a option -> 'b option -> 'c option) ->
+           f:(key -> 'a option -> 'b option -> 'c option) ->
            'a t -> 'b t -> 'c t
       (** [merge f m1 m2] computes a map whose keys are a subset of the keys of
           [m1] and of [m2]. The presence of each such binding, and the
     end
   (** Output signature of the functor {!Make}. *)
 
-  module Make (Ord : OrderedType) : S with type key = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type key = Ord.t
+     and type 'a t = 'a Map.Make(Ord).t
   (** Functor building an implementation of the map structure
      given a totally ordered type. *)
+
   (** Sets over ordered types.
 
      This module implements the set data structure, given a total ordering
     end
   (** Output signature of the functor {!Make}. *)
 
-  module Make (Ord : OrderedType) : S with type elt = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type elt = Ord.t
+     and type t = Set.Make(Ord).t
   (** Functor building an implementation of the set structure
      given a totally ordered type. *)
+
+end
