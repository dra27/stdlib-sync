 (** The equality function for byte sequences.
     @since 4.03.0 (4.05.0 in BytesLabels) *)
 
-val starts_with : prefix:bytes -> bytes -> bool
-(** [starts_with ~prefix s] is [true] if and only if [s] starts with
+val starts_with : bytes -> bytes -> bool
+(** [starts_with prefix s] is [true] if and only if [s] starts with
     [prefix].
 
     @since 4.13.0 *)
 
-val ends_with : suffix:bytes -> bytes -> bool
-(** [ends_with ~suffix s] is [true] if and only if [s] ends with [suffix].
+val ends_with : bytes -> bytes -> bool
+(** [ends_with suffix s] is [true] if and only if [s] ends with [suffix].
 
     @since 4.13.0 *)
 
 (** [compare s0 s1] sorts [s0] and [s1] in lexicographical order. [compare]
     behaves like {!Stdlib.compare} on strings but may be more efficient. *)
 
-val starts_with : prefix:string -> string -> bool
-(** [starts_with ~prefix s] is [true] if and only if [s] starts with [prefix].
+val starts_with : string -> string -> bool
+(** [starts_with prefix s] is [true] if and only if [s] starts with [prefix].
 
     @since 4.12.0 *)
 
-val ends_with : suffix:string -> string -> bool
-(** [ends_with ~suffix s] is [true] if and only if [s] ends with [suffix].
+val ends_with : string -> string -> bool
+(** [ends_with suffix s] is [true] if and only if [s] ends with [suffix].
 
     @since 4.12.0 *)
 
    [link(2)] function is used whose behaviour is OS-dependent, but more widely
    available.
 
-   @raise ENOSYS On {e Unix} if [~follow:_] is requested, but linkat is
+   @raise ENOSYS On {e Unix} if [follow:_] is requested, but linkat is
                  unavailable.
-   @raise ENOSYS On {e Windows} if [~follow:false] is requested. *)
+   @raise ENOSYS On {e Windows} if [follow:false] is requested. *)
 
 
 (** {1 File permissions and ownership} *)
    the Unix module that create file descriptors have an optional
    argument [?cloexec:bool] to indicate whether the file descriptor
    should be created in ``close-on-exec'' mode (by writing
-   [~cloexec:true]) or in ``keep-on-exec'' mode (by writing
-   [~cloexec:false]).  For historical reasons, the default file
+   [cloexec:true]) or in ``keep-on-exec'' mode (by writing
+   [cloexec:false]).  For historical reasons, the default file
    descriptor creation mode is ``keep-on-exec'', if no [cloexec] optional
    argument is given.  This is not a safe default, hence it is highly
    recommended to pass explicit [cloexec] arguments to operations that
    completes.  If another thread spawns another program during this window,
    the descriptor will leak, as it is still in the ``keep-on-exec'' mode.
 
-   Regarding the atomicity guarantees given by [~cloexec:true] or by
+   Regarding the atomicity guarantees given by [cloexec:true] or by
    the use of the [O_CLOEXEC] flag: on all platforms it is guaranteed
    that a concurrently-executing Caml thread cannot leak the descriptor
    by starting a new process.  On Linux, this guarantee extends to
   (** {1 Generic interface} *)
 
 
-  type (!'a, !'b) t
+  type (!'a, !'b) t = ('a, 'b) Hashtbl.t
   (** The type of hash tables from type ['a] to type ['b]. *)
 
   val create : ?random:bool -> int -> ('a, 'b) t
      the table.  The table grows as needed, so [n] is just an
      initial guess.
 
-     The optional [~random] parameter (a boolean) controls whether
+     The optional [random] parameter (a boolean) controls whether
      the internal organization of the hash table is randomized at each
      execution of [Hashtbl.create] or deterministic over all executions.
 
-     A hash table that is created with [~random] set to [false] uses a
+     A hash table that is created with [random] set to [false] uses a
      fixed hash function ({!hash}) to distribute keys among
      buckets.  As a consequence, collisions between keys happen
      deterministically.  In Web-facing applications or other
      denial-of-service attack: the attacker sends input crafted to
      create many collisions in the table, slowing the application down.
 
-     A hash table that is created with [~random] set to [true] uses the seeded
+     A hash table that is created with [random] set to [true] uses the seeded
      hash function {!seeded_hash} with a seed that is randomly chosen at hash
      table creation time.  In effect, the hash function used is randomly
      selected among [2^{30}] different hash functions.  All these hash
      or {!iter} is no longer deterministic: elements are enumerated in
      different orders at different runs of the program.
 
-     If no [~random] parameter is given, hash tables are created
+     If no [random] parameter is given, hash tables are created
      in non-random mode by default.  This default can be changed
      either programmatically by calling {!randomize} or by
      setting the [R] flag in the [OCAMLRUNPARAM] environment variable.
 
-     @before 4.00.0 the [~random] parameter was not present and all
+     @before 4.00.0 the [random] parameter was not present and all
      hash tables were created in non-randomized mode. *)
 
   val clear : ('a, 'b) t -> unit
   val randomize : unit -> unit
   (** After a call to [Hashtbl.randomize()], hash tables are created in
       randomized mode by default: {!create} returns randomized
-      hash tables, unless the [~random:false] optional parameter is given.
+      hash tables, unless the [random:false] optional parameter is given.
       The same effect can be achieved by setting the [R] parameter in
       the [OCAMLRUNPARAM] environment variable.
 
       Note that once [Hashtbl.randomize()] was called, there is no way
       to revert to the non-randomized default behavior of {!create}.
       This is intentional.  Non-randomized hash tables can still be
-      created using [Hashtbl.create ~random:false].
+      created using [Hashtbl.create random:false].
 
       @since 4.00.0 *)
 
       @since 4.12.0 *)
 
   (** @since 4.00.0 *)
-  type statistics = {
+  type statistics = Hashtbl.statistics = {
     num_bindings: int;
       (** Number of bindings present in the table.
           Same value as returned by {!length}. *)
     end
   (** The output signature of the functor {!Make}. *)
 
-  module Make (H : HashedType) : S with type key = H.t
+    module Make : functor (H : HashedType) -> S
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.Make(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.Make] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
   (** The output signature of the functor {!MakeSeeded}.
       @since 4.00.0 *)
 
-  module MakeSeeded (H : SeededHashedType) : SeededS with type key = H.t
+    module MakeSeeded (H : SeededHashedType) : SeededS
+    with type key = H.t
+     and type 'a t = 'a Hashtbl.MakeSeeded(H).t
   (** Functor building an implementation of the hashtable structure.
       The functor [Hashtbl.MakeSeeded] returns a structure containing
       a type [key] of keys and a type ['a t] of hash tables
       interface, but use the seeded hashing and equality functions
       specified in the functor argument [H] instead of generic
       equality and hashing.  The [create] operation of the
-      result structure supports the [~random] optional parameter
-      and returns randomized hash tables if [~random:true] is passed
+      result structure supports the [random] optional parameter
+      and returns randomized hash tables if [random:true] is passed
       or if randomization is globally on (see {!Hashtbl.randomize}).
       @since 4.00.0 *)
 
      an integer seed.  Usage:
      [Hashtbl.seeded_hash_param meaningful total seed x].
      @since 4.00.0 *)
+
   (** Association tables over ordered types.
 
      This module implements applicative association tables, also known as
          @before 4.03 Physical equality was not ensured. *)
 
       val merge:
-           (key -> 'a option -> 'b option -> 'c option) ->
+           f:(key -> 'a option -> 'b option -> 'c option) ->
            'a t -> 'b t -> 'c t
       (** [merge f m1 m2] computes a map whose keys are a subset of the keys of
           [m1] and of [m2]. The presence of each such binding, and the
     end
   (** Output signature of the functor {!Make}. *)
 
-  module Make (Ord : OrderedType) : S with type key = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type key = Ord.t
+     and type 'a t = 'a Map.Make(Ord).t
   (** Functor building an implementation of the map structure
      given a totally ordered type. *)
+
   (** Sets over ordered types.
 
      This module implements the set data structure, given a total ordering
     end
   (** Output signature of the functor {!Make}. *)
 
-  module Make (Ord : OrderedType) : S with type elt = Ord.t
+    module Make : functor (Ord : OrderedType) -> S
+    with type elt = Ord.t
+     and type t = Set.Make(Ord).t
   (** Functor building an implementation of the set structure
      given a totally ordered type. *)
+
+end
